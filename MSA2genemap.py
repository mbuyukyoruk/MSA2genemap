import argparse
import os
import sys
import subprocess
import time
import uuid
import bisect
import textwrap

try:
    from ali2csv import main as ali2df
except ImportError as e:
    print("Unable to find ali2csv dependency in the $PATH. Please make sure the MSA2genemap folder is in the path.")
    sys.exit()

try:
    import tqdm
except ImportError as e:
    print("tqdm module is not installed! Please install tqdm and try again.")
    sys.exit()

try:
    import pandas as pd
except ImportError as e:
    print("pandas module is not installed! Please install pandas and try again.")
    sys.exit()


def initiate(raw_args=None):
    parser = argparse.ArgumentParser(prog='python MSA2genemap.py',
                                 formatter_class=argparse.RawDescriptionHelpFormatter,
                                 epilog=textwrap.dedent('''\

# MSA2genemap

Author: Murat Buyukyoruk

        MSA2genemap help:

This script is developed to generate a dataframe by using the MSA file that can be used with Phylo_2_genemap script. 

Syntax (one of the command lines from simpler to more advanced):

        python MSA2genemap.py -i demo.fasta -o out.txt      #This will generate a dataframe to visualize all residues of an alignment.
    
        python MSA2genemap.py -i demo.fasta -o out.txt -k demo_key.txt      #This will generate a dataframe where each residue is colored by the corrsponding domain.
    
        python MSA2genemap.py -i demo.fasta -o out.txt -k demo_key.txt -s CC1 IS2 CC2       #This will generate a dataframe where only specified domains are expanded while the rest are collapsed.
    
        python MSA2genemap.py -i demo.fasta -o out.txt -k demo_key.txt -s CC1 IS2 CC2 -r demo_residue.txt       #This will generate a dataframe where some residued can be highlighed unless they are locaed in a collapsed domain.
        
### Input file example:

Example dataframe for the key file (tab separated excel file is required):

        Accession	    Position	Key
        WP_001007866.1	1-5	        N-term
        WP_001007866.1	6-101	    NBD1
        WP_001007866.1	102-199	    IS1
        WP_001007866.1	200-239	    CC1
        WP_001007866.1	240-292	    IS2
        WP_001007866.1	293-350	    CC2
        WP_001007866.1	351-435	    NBD2
        WP_001007866.1	436-464	    C-term

Example dataframe for the residue file (tab separated excel file is required):

        Accession	    Residue
        WP_001007866.1	212
        WP_001007866.1	213
        WP_001007866.1	224
        WP_001007866.1	345
        WP_001007866.1	346

### Output files

As an output dataframe file(s) will be generated which is compatible with [Phylo_2_genemap.py](https://github.com/mbuyukyoruk/Phylo_2_genemap) script. Depending on the used arguments one or two files will be generate.
User defined output file will generate an unedited dataframe file where each residue/domain is represented with each line along with their GAPs in the alingment multifasta. If "-s Domain1 Domain2" option was used (requires "-k key.txt" file) an additional file will be generated that contains the adjusted domain boundries to expand the requested domains in the final figure generated by Phylo_2_genemap.

The format of .clst file will look like:
    molecule	    ORF	            gene	Residue	start	end	    strand	    orientation
    WP_000334847.1	WP_000334847.1	N-term	NA	    1263	1267	forward	    1
    WP_000334847.1	WP_000334847.1	NBD1	NA	    1268	1373	forward	    1
    WP_000334847.1	WP_000334847.1	IS1	    NA	    1374	1503	forward	    1
    WP_000334847.1	WP_000334847.1	Start	NA	    1503	1504	forward	    1
    WP_000334847.1	WP_000334847.1	CC1	    F	    1504	1505	forward	    1
    WP_000334847.1	WP_000334847.1	CC1	    D	    1505	1506	forward	    1
    WP_000334847.1	WP_000334847.1	GAP	    -	    1506	1524	forward	    1
    WP_000334847.1	WP_000334847.1	CC1	    V	    1524	1525	forward	    1
    WP_000334847.1	WP_000334847.1	CC1	    E	    1525	1526	forward	    1
    ...

Example usage of Phylo_2_genemap with this dataset is provided below:

        Phylo_2_genemap.py -t demo_tree.newick -o phylogeny -a Start -g out_CC1_IS2_CC2.txt         #use output file from MSA2genemap for -g argument.
        

MSA2genemap dependencies:

R                                                       refer to https://rstudio-education.github.io/hopr/starting.html

tqdm                                                    refer to https://pypi.org/project/tqdm/

ali2csv                                                 provided in this repository

pandas                                                  refer to https://pandas.pydata.org/

Bio module, SeqIO and Seq available in this package     refer to https://biopython.org/wiki/Download


Input Paramaters (REQUIRED):
----------------------------
	-i/--input      MSA     		    Specify input file of a multiple-sequence alignment (MSA) file.

	-o/--output     outfile 		    Specify a output file name.

Parameters [optional]:
----------------------

	-k/--key        Key_file            Specify a key file containing a reference accession, residue positions and domain name to use it as reference to the rest of the MSA.

	-s/--show_dom   DOMAIN_name		    Specify a list of domain names (separated with blank space, i.e., Domain1 Domain2) to expand these domains, while collapsing the rest.

	-r/--residue    Residue_file        Specify a residue file containing the reference accession and the residue positions that you would like to highlight.

Basic Options:
--------------
	-h/--help		HELP		        Shows this help text and exits the run.

      	'''))
    parser.add_argument('-i', '--input', required=True, type=str, dest='filename',
                        help='Specify a MSA file.\n')
    parser.add_argument('-o', '--output', required=True, dest='out',
                        help='Specify a output file name.\n')
    parser.add_argument('-k', '--key', required=False, dest='key', default=None,
                        help='Specify a key file.\n')
    parser.add_argument('-s', '--show_dom', required=False, dest='show', default=None, nargs="+",
                        help='Specify a domain to expand as alinged residues.\n')
    parser.add_argument('-r', '--residue', required=False, dest='residue', default=None,
                        help='Specify list of residues to highlight (requires --show_dom).\n')

    orig_stdout = sys.stdout

    results = parser.parse_args(raw_args)

    filename = results.filename
    out = results.out
    key = results.key
    show = results.show
    residue = results.residue

    if residue is not None and key is None:
        parser.error('The --residue (-r) argument requires the --key (-k) argument.')
    if show is not None and key is None:
        parser.error('The --show_dom (-s) argument requires the --key (-k) argument.')

    return filename, out, key, show, residue, orig_stdout


def generate_df(msa):
    df = "/tmp/" + str(uuid.uuid4())
    ali2df(["-i", msa, "-o", df])
    return df


def generate_key(df, key):
    key_file = "/tmp/" + str(uuid.uuid4())
    df_key = pd.read_csv(key, sep='\t', lineterminator='\n')
    ref_acc = df_key.Accession.unique()

    boundaries = []
    boundary_result = []

    if len(ref_acc) != 1:
        print("Found multiple reference accessions. Please provide domain positions for single accession in key file.")
        os.system("rm " + df)
        sys.exit()

    else:
        for i in range(len(df_key.columns)):
            if "\r" in df_key.iloc[:, i:i + 1].columns[0]:
                df_key[df_key.iloc[:, i:i + 1].columns[0]] = df_key[df_key.iloc[:, i:i + 1].columns[0]].str.replace(
                    '\r', '')
                df_key = df_key.rename(
                    columns={df_key.iloc[:, i:i + 1].columns[0]: df_key.iloc[:, i:i + 1].columns[0].replace("\r", "")})
        df_key = df_key.reset_index()
        for index, row in df_key.iterrows():
            pos = row['Position'].split("-")
            stop = int(pos[1])
            annotation = row['Key'].replace("\r", "")

            boundaries.append(stop)
            boundary_result.append(annotation)

        def boundaries(num, breakpoints=boundaries, result=boundary_result):
            intersect = bisect.bisect(breakpoints, num - 1)
            return result[intersect]

    df_ali = pd.read_csv(df, sep='\t', lineterminator='\n')
    arr = df_ali[df_ali['0'].str.contains(ref_acc[0])].values.flatten().tolist()
    f = open(key_file, "a")
    sys.stdout = f
    print("Position\tKey")
    for i in range(1, len(arr)):
        len_ali = len("".join(arr[1:i]).replace("-", ""))
        key_finder = boundaries(len_ali)
        print(str(i) + "\t" + key_finder)

    return key_file


def df_to_genemap(df, key_file, orig_stdout, residue, show):
    pos_list = []
    key_list = []

    tmp = "/tmp/" + str(uuid.uuid4())

    f = open(tmp, 'a')
    sys.stdout = f

    if key_file is not None:
        with open(key_file, 'r') as file:
            for line in file:
                if line.split("\t")[0] != "Position":
                    position = line.split("\t")[0]
                    aa = line.split("\t")[1].split("\n")[0]
                    pos_list.append(position)
                    key_list.append(aa)

    print("molecule\tORF\tgene\tResidue\tstart\tend\tstrand\torientation")

    proc = subprocess.Popen("wc -l < " + df, shell=True, stdout=subprocess.PIPE, text=True)
    length = int(proc.communicate()[0].split('\n')[0])

    with tqdm.tqdm(range(length + 1), desc='Adding Domain Annotations...') as pbar:
        with open(df, 'r') as file:
            for line in file:
                pbar.update()
                if line[0] != "0":
                    arr = line.replace("\n", '').split("\t")
                    seq = arr[0]
                    aligned = "".join(arr[1:])
                    unaligned = aligned.replace("-", "")
                    print(seq.split()[0] + "\t" + seq.split()[0] + "\tStart\tNA\t1\t2\tforward\t1")
                    for ii in range(len(aligned)):
                        if len(aligned[0:ii].replace("-", "")) == 0:
                            pass
                        elif 0 < len(aligned[0:ii].replace("-", "")) <= len(unaligned):
                            if aligned[ii - 1] != "-":
                                if key_file is not None:
                                    print(seq.split()[0] + "\t" + seq.split()[0] + "\t" + key_list[ii - 1] + "\t" +
                                          aligned[
                                              ii - 1] + "\t" + str(ii) + "\t" + str(ii + 1) + "\tforward\t1")
                                else:
                                    print(seq.split()[0] + "\t" + seq.split()[0] + "\t" + aligned[ii - 1] + "\t" +
                                          aligned[ii - 1] + "\t" + str(ii) + "\t" + str(ii + 1) + "\tforward\t1")
                            else:
                                print(
                                    seq.split()[0] + "\t" + seq.split()[0] + "\tGAP\t" + aligned[ii - 1] + "\t" + str(
                                        ii) + "\t" + str(
                                        ii + 1) + "\tforward\t1")
                        if len(aligned[0:ii].replace("-", "")) >= len(unaligned):
                            break

    f.close()
    time.sleep(1)
    sys.stdout = orig_stdout
    if residue is None:
        os.system("rm " + df)
    if key_file is not None:
        if show is None:
            os.system("rm " + key_file)
    return tmp


def gap_adjust(tmp, out, orig_stdout):
    region = []

    os.system('> ' + out)

    f = open(out, 'a')
    sys.stdout = f

    proc = subprocess.Popen("wc -l < " + tmp, shell=True, stdout=subprocess.PIPE, text=True)
    length = int(proc.communicate()[0].split('\n')[0])

    with tqdm.tqdm(range(length + 1), desc='Combining...') as pbar:
        with open(tmp, 'r') as file:
            for line in file:
                pbar.update()
                arr = line.replace("\n", "").split("\t")
                if arr[0] == "molecule":
                    acc_prev = None
                    name_prev = None
                    gene_prev = None
                    residue_prev = None
                    start_prev = None
                    end_prev = None
                    strand_prev = None
                    orientation_prev = None
                    print(line.split("\n")[0])
                else:
                    acc = arr[0]
                    name = arr[1]
                    gene = arr[2]
                    residue = arr[3]
                    start = int(arr[4])
                    end = int(arr[5])
                    strand = arr[6]
                    orientation = arr[7]

                    if acc != acc_prev:
                        print(line.split("\n")[0])
                        region = []

                    elif acc == acc_prev:
                        if gene != "GAP":
                            if gene_prev != "GAP":
                                print(line.split("\n")[0])
                            elif gene_prev == "GAP":
                                print(acc_prev + "\t" + name_prev + "\t" + gene_prev + "\t-\t" + str(
                                    min(region)) + "\t" + str(max(region)) + "\tforward\t1")
                                print(line.split("\n")[0])
                                region = []
                        elif gene == "GAP":
                            region.append(start)
                            region.append(end)
                    acc_prev = acc
                    name_prev = name
                    gene_prev = gene
                    residue_prev = residue
                    start_prev = start
                    end_prev = end
                    strand_prev = strand
                    orientation_prev = orientation

    os.system("rm " + tmp)
    sys.stdout = orig_stdout


def merge(input_file, gene_show, key_df):
    df_key_mini = pd.read_csv(key_df, sep='\t', lineterminator='\n')
    df_key_mini_sub = df_key_mini[df_key_mini['Key'].isin(gene_show)]
    new_start = df_key_mini_sub.Position.min()
    new_end = df_key_mini_sub.Position.max()

    df_all = pd.read_csv(input_file, sep='\t', lineterminator='\n')

    final = pd.DataFrame()

    with tqdm.tqdm(range(len(df_all.molecule.unique())), desc='Adjusting...') as pbar:
        for i in range(len(df_all.molecule.unique())):
            try:
                df = df_all[df_all['molecule'] == df_all.molecule.unique()[i]]

                target_rows = df[df['gene'].isin(gene_show)]
                target_range = range(target_rows['start'].min(), target_rows['end'].max())

                df_update = df[(df['gene'].isin(gene_show)) | ((df['gene'] == 'GAP') & df['start'].isin(target_range))]

                df_remaining_1 = df[df['end'] < min(target_range)]
                df_remaining_2 = df[df['start'] > max(target_range)]

                df_remaining = df_remaining_1
                df_remaining = df_remaining[(df_remaining['gene'] != 'GAP') & (df_remaining['gene'] != 'Start')]

                df_remaining_uniq = df_remaining.drop_duplicates(subset=['molecule', 'gene'])

                df_remaining_uniq = df_remaining_uniq.sort_values(by=['start'])

                target_start = new_start
                current_position = target_start - 1

                for index, row in df_remaining_uniq.iloc[::-1].iterrows():
                    gene_length = df_remaining[df_remaining['gene'] == row['gene']]["gene"].value_counts()[row['gene']]
                    df_remaining_uniq.at[index, 'end'] = current_position
                    df_remaining_uniq.at[index, 'start'] = current_position - gene_length + 1
                    df_remaining_uniq.at[index, 'Residue'] = "NA"
                    current_position -= gene_length

                df_remaining_uniq_1 = df_remaining_uniq

                start_row = {
                    'molecule': target_rows.iloc[0]['molecule'],
                    'ORF': target_rows.iloc[0]['ORF'],
                    'gene': 'Start',
                    'Residue': 'NA',
                    'start': new_start - 1,
                    'end': new_start,
                    'strand': target_rows.iloc[0]['strand'],
                    'orientation': target_rows.iloc[0]['orientation']
                }
                df_start = pd.DataFrame([start_row])

                df_remaining = df_remaining_2
                df_remaining = df_remaining[(df_remaining['gene'] != 'GAP') & (df_remaining['gene'] != 'Start')]

                df_remaining_uniq = df_remaining.drop_duplicates(subset=['molecule', 'gene'])

                df_remaining_uniq = df_remaining_uniq.sort_values(by=['start'])

                target_end = new_end
                current_position = target_end

                for index, row in df_remaining_uniq.iterrows():
                    gene_length = df_remaining[df_remaining['gene'] == row['gene']]["gene"].value_counts()[row['gene']]
                    df_remaining_uniq.at[index, 'start'] = current_position
                    df_remaining_uniq.at[index, 'end'] = current_position + gene_length
                    df_remaining_uniq.at[index, 'Residue'] = "NA"
                    current_position += gene_length

                df_remaining_uniq_2 = df_remaining_uniq

                final_df = pd.concat([df_remaining_uniq_1, df_remaining_uniq_2, df_update, df_start]).sort_values(
                    by=['start', 'gene']).reset_index(drop=True)

                final = pd.concat([final, final_df]).reset_index(drop=True)
                pbar.update()
            except:
                print(df_all.molecule.unique()[i] + " doesn't have " + ", ".join(
                    gene_show) + " domain(s)! Skipping the accession.")
    os.system("rm " + key_df)
    return final


def residue_add(df, residue):
    ref_acc = []
    ref_res = []
    ref_res_ori = []
    ref_res_conv = []

    final_res = pd.DataFrame()

    with open(residue, 'r') as file:
        for line in file:
            if "Accession" not in line:
                arr = line.split("\n")[0].split("\t")
                if arr[0] not in ref_acc:
                    ref_acc.append(arr[0])
                ref_res.append(int(arr[1]))
                ref_res_ori.append(int(arr[1]))

    if len(ref_acc) != 1:
        print(
            "Found multiple reference accessions. Please provide domain positions for single accession in residue file."
        )
        os.system("rm " + df)
        sys.exit()

    df_ali = pd.read_csv(df, sep='\t', lineterminator='\n')
    arr = df_ali[df_ali['0'].str.contains(ref_acc[0])].values.flatten().tolist()

    for i in range(1, len(arr)):
        len_ali = len("".join(arr[1:i]).replace("-", ""))
        if len_ali in ref_res:
            ref_res_conv.append(i - 1)
            ref_res.remove(len_ali)

    with tqdm.tqdm(range(len(ref_res_conv)), desc='Adding Residues...') as pbar:
        for i in range(len(ref_res_conv)):
            res = pd.DataFrame()
            res['molecule'] = df_ali['0'].str.split(' ', expand=True)[0]
            res['ORF'] = df_ali['0'].str.split(' ', expand=True)[0]
            res['gene'] = df_ali[(str(ref_res_conv[i]))]
            res['Residue'] = str(ref_res_ori[i])
            res['start'] = str(ref_res_conv[i])
            res['end'] = str(ref_res_conv[i] + 1)
            res['strand'] = 'forward'
            res['orientation'] = '1'

            final_res = pd.concat([final_res, res]).reset_index(drop=True)
            pbar.update()

    os.system("rm " + df)
    return final_res


def main():
    filename, out, key, show, residue, orig_stdout = initiate()

    df = generate_df(filename)

    if key is not None:
        key_df = generate_key(df, key)
    else:
        key_df = None

    tmp = df_to_genemap(df, key_df, orig_stdout, residue, show)
    gap_adjust(tmp, out, orig_stdout)
    if show is not None:
        final = merge(out, show, key_df)
        if residue is not None:
            df_res = residue_add(df, residue)
            final = pd.concat([final, df_res]).reset_index(drop=True)
        output_file = out.split(".")[0] + "_" + "_".join(show) + ".txt"
        final.to_csv(output_file, sep='\t', index=False, header=True)


if __name__ == '__main__':
    main()
